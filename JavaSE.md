[TOC]

# Java学习路线

![image-20220103190134885](image/image-20220103190134885.png)

![Java后端开发学习路线-高清版](image/Java后端开发学习路线-高清版.jpg)

# 概念

## 计算机语言

![1600835887339](image/1600835887339.png)



## jdk相关的基本概念

- jdk是用来开发Java程序的
- jdk包含jre

> 如果我们只需要运行Java程序，只需要安装jre，如果需要开发和运行Java程序，则需要安装jdk

- jvm是将Java程序翻 现Java程序的跨平台性

![1600836206164](image/1600836206164.png)

**jvm是用来保证Java程序跨平台的，它本身是不能跨平台的**

如果需要在windows系统运行Java程序，则需要安装windows版本的jvm

其他系统如此类推

![1600836375590](image/1600836375590.png)





## 第一个Java程序：Hello world

![1600838783265](image/1600838783265.png)

![1600838799497](image/1600838799497.png)

![1600838875514](image/1600838875514.png)

![1600838912629](image/1600838912629.png)



## Java程序开发于运行原理



Java程序开发分为三个阶段，

- 第一个阶段是源文件阶段，即Java文件，这个文件计算机是看不懂的，只有程序员看得懂
- 当我们点击运行之后，idea会调用javac.exe这个程序，将Java文件编译成class字节码文件（计算机看得懂，程序员看不懂）（这个过程和jvm有关）
- idea调用、
- 结果输出到控制台上（这个过程和jre有关）

![1600840236121](image/1600840236121.png)

## idea常用快捷键

![1600847559260](image/1600847559260.png)





## Java语言编码规范

![1600850217610](image/1600850217610.png)

![1600850226154](image/1600850226154.png)

![1600850259029](image/1600850259029.png)

![1600850272810](image/1600850272810.png)

![1600850293486](image/1600850293486.png)

![1600850305254](image/1600850305254.png)





# Java核心（常量、变量）

## 注释

![1600850466997](image/1600850466997.png)



## 关键字

- **被Java语言赋予特定含义的单词**

![1600850569665](image/1600850569665.png)

![1600850584102](image/1600850584102.png)

![1600850601089](image/1600850601089.png)

![1600850611750](image/1600850611750.png)

![1600850620403](image/1600850620403.png)



## 常量

![1600850726492](image/1600850726492.png)

## 变量

![image-20200924005014184](image/image-20200924005014184.png)

![image-20200924005102277](image/image-20200924005102277.png)

## 数据类型

![image-20200924005440098](image/image-20200924005440098.png)

![image-20200924010232445](image/image-20200924010232445.png)

## 数据类型转换

-  隐式类型转换：瘦子穿宽衣服
- 显式类型转换：胖子穿小衣服

<img src="image/image-20200924011800979.png" alt="image-20200924011800979" style="zoom:200%;" />

**当byte和int类型进行运算时，会先将byte提升为int类型再计算，结果也是int类型**

例子如下

![image-20200924012200829](image/image-20200924012200829.png)

**所以只能通过强类型装换来转换成byte**

![image-20200924012542299](image/image-20200924012542299.png)

大类型转换成小类型丢失精度举例

![image-20200924012807527](image/image-20200924012807527.png)

> **数组不能进行强制类型转换**



## 标识符

<img src="image/image-20200924012926061.png" alt="image-20200924012926061" style="zoom:200%;" />



# Java核心（运算）

![image-20200924083354666](image/image-20200924083354666.png)

## 算术运算符

![image-20200924084126274](image/image-20200924084126274.png)

## 字符和字符串参与加法运算

![image-20200924084642810](image/image-20200924084642810.png)

举例如下

![image-20200924084916616](image/image-20200924084916616.png)

## 自增和自减运算符

![image-20200924085350017](image/image-20200924085350017.png)

![image-20200924090951389](image/image-20200924090951389.png)

## 赋值运算符

![image-20200924091229656](image/image-20200924091229656.png)

![image-20200924091243726](image/image-20200924091243726.png)



## 关系运算符

![image-20200924091346790](image/image-20200924091346790.png)



## 逻辑运算符

![image-20200924113940270](image/image-20200924113940270.png)

## 三元运算符

![image-20200924114200213](image/image-20200924114200213.png)

案例

![image-20200924114523168](image/image-20200924114523168.png)

# Java核心（流程控制之选择结构）

## 流程控制的结构之顺序结构

![image-20200924120044925](image/image-20200924120044925.png)

## 选择结构的概述

![image-20200924120153270](image/image-20200924120153270.png)





**分为两大类**

- if语句(if)（if else）（if else if）——三种格式
- switch语句

> <img src="image/image-20200924120757434.png" alt="image-20200924120757434" style="zoom:150%;" />



# Java核心（循环结构）

## for循环

## while循环

## do....while循环

## 两种简单的死循环

![image-20200924123607632](image/image-20200924123607632.png)

## break和continue

![image-20200924152528917](image/image-20200924152528917.png)

![image-20200924152630269](image/image-20200924152630269.png)

**continue**

![image-20200924152711979](image/image-20200924152711979.png)

![image-20200924152924521](image/image-20200924152924521.png)

## Random类的简单使用

![image-20200924153347145](image/image-20200924153347145.png)

# Java核心（方法和数组）

## 方法的格式

![image-20200924153817432](image/image-20200924153817432.png)

## 方法的定义和调用（形式参数和实际参数）

![image-20200924155634418](image/image-20200924155634418.png)

## 定义方法的注意事项

![image-20200924160048961](image/image-20200924160048961.png)

## 方法重载

![image-20200924181718492](image/image-20200924181718492.png)

## 数组

**数组的三种定义格式**

![image-20200925130537765](image/image-20200925130537765.png)

![image-20200925131820184](image/image-20200925131820184.png)

![image-20200925130849313](image/image-20200925130849313.png)



**数组的初始化**

![image-20200925140135616](image/image-20200925140135616.png)



![image-20200925140229105](image/image-20200925140229105.png)

## Java程序的内存分配（重点）

![image-20200925141404632](image/image-20200925141404632.png)



**数组动态初始化图解**

![image-20200925141854266](image/image-20200925141854266.png)

**数组的静态初始化图解**

![image-20200925142037807](image/image-20200925142037807.png)

**两个数组的内存图解**

![image-20200925142331294](image/image-20200925142331294.png)

**一个数组两个引用的内存图解**

![image-20200925142836250](image/image-20200925142836250.png)

**数组索引越界**

![image-20200925143350560](image/image-20200925143350560.png)

**空指针异常**

![image-20200925143639413](image/image-20200925143639413.png)

**定义打印数组元素的方法并调用过程图解**

![image-20200926132026096](image/image-20200926132026096.png)



# Java编程思想（面向对象封装）



 ![image-20200926132749765](image/image-20200926132749765.png)

## 面向对象概述

![image-20200926133315415](image/image-20200926133315415.png)

**理解**：比如一个对象是一个人，这个人会很多技能，比如洗衣服、做饭、洗碗等等

而在Java中，上面的那个人就是一个对象（类——class）

而上面那个人所会的技能，就相当于Java类中的方法

我们作为指挥者，会有很多个class（类）就是人，所以我们可以调用（new）一个人（对象），然后调用这个人（对象）的方法

如果没有这个对象，那么我们可以创建一个类（对象）

类就是代表一

类事物，比如手机类，甜品类 ，衣服类等等

## 如何描述一个事物（对象）

![image-20200926133946852](image/image-20200926133946852.png)



![image-20200926134243366](image/image-20200926134243366.png)

![image-20200926134408142](image/image-20200926134408142.png)

 类的定义、创建和使用

![image-20200926134602024](image/image-20200926134602024.png)

![image-20200926134816145](image/image-20200926134816145.png)



**举例**

![image-20200926135826942](image/image-20200926135826942.png)

## 一个对象创建过程的内存图解

![image-20200926140240200](image/image-20200926140240200.png)





## 两个对象创建过程的内存图解

![image-20200926141109253](image/image-20200926141109253.png)



## 对象作为参数的内存图解

![image-20200926142324698](image/image-20200926142324698.png)



## Java中使用变量的规则

![image-20200926142454483](image/image-20200926142454483.png)

## 成员变量和局部变量的区别

![image-20200926143154303](image/image-20200926143154303.png)

![image-20200926143256063](image/image-20200926143256063.png)

## 封装的概述

![image-20200926143349495](image/image-20200926143349495.png)



![image-20200926143609418](image/image-20200926143609418.png)



## private关键字

![image-20200926143857179](image/image-20200926143857179.png)



![image-20200926144006507](image/image-20200926144006507.png)

**案例：创建一个类，然后给这个类的成员变量添加private关键字**

思考：我们如果才能在其他类中使用到被private修饰的成员变量呢

答：我们可以添加这些成员属性的公共方法，然后通过其他类调用这些公共方法实现调用私有化的成员属性



## this关键字

![image-20200926145129901](image/image-20200926145129901.png)

**举例**

![image-20200926145326290](image/image-20200926145326290.png)

**JavaBean**（构造方法）

![image-20200926145523559](image/image-20200926145523559.png)

![image-20200926145848293](image/image-20200926145848293.png)

**注意：带有返回值类型的与类同名的方法不是构造方法**

![image-20200926150044233](image/image-20200926150044233.png)

**构造方法的要求**

![image-20200926150213899](image/image-20200926150213899.png)

**带参构造方法举例**

![image-20200926150338023](image/image-20200926150338023.png)



## 标准的JavaBean类的定义的和使用

 ![image-20200926151155197](image/image-20200926151155197.png)



一个标准的JavaBean举例

![image-20200926151329077](image/image-20200926151329077.png)

![image-20200926151413624](image/image-20200926151413624.png)



# Java编程思想（面向对象继承）

![image-20200926151751739](image/image-20200926151751739.png)



## 继承的概述

![image-20200926152134636](image/image-20200926152134636.png)

![image-20200926152235910](image/image-20200926152235910.png)

**重点：在Java的继承中，子类只能继承父类的非私有成员变量和方法**

## 继承_动物类演示

![image-20200926153949569](image/image-20200926153949569.png)

**当我们分别定义一个猪类和一个狗类的时候**

![image-20200926154211476](image/image-20200926154211476.png)

- 可以看到，因为猪类和狗类有很多共通的特点，只有watch()和snore()这两个技能不同，所以，我们可以把他们两者共同的属性和技能整合到animal类中，然后让dog类和pig类继承animal类就能获取他们共同的特点了

![image-20200926154318231](image/image-20200926154318231.png)

## 继承的优缺点

![image-20200926155501654](image/image-20200926155501654.png)

关于继承会破坏封装性的理解，以及继承为什么会造成高耦合

![image-20200926155303340](image/image-20200926155303340.png)



**程序设计的追求**

![image-20200926155551164](image/image-20200926155551164.png)

## 继承关系中成员变量的使用

![image-20200926170358906](image/image-20200926170358906.png)



继承关系中，成员变量的使用图解

![image-20200926170633908](image/image-20200926170633908.png)

![image-20200926173728714](image/image-20200926173728714.png)

## super关键字的使用

可以用来调用父类的成员变量和成员方法

```Java
super.name;
super.show()
```

用来调用父类的构造方法

```java
super()不带参
super(参数1、参数2)
```

**注意：**

![image-20200926173437783](image/image-20200926173437783.png)

![image-20200926173758300](image/image-20200926173758300.png)

## this和super关键字的区别

![image-20200926173908688](image/image-20200926173908688.png)

## 继承关系中成员方法的使用图解

![image-20200926175824709](image/image-20200926175824709.png)

![image-20200926175853519](image/image-20200926175853519.png)



## 子父类构造方法的使用



![image-20200926180130351](image/image-20200926180130351.png)

**如果父类没有无参构造方法，那么子类应该怎么调用父类的构造方法呢**

![image-20200926180336958](image/image-20200926180336958.png)



**子类的构造方法第一行必须是super()，否则就会报错**

![image-20200926181203110](image/image-20200926181203110.png)



## 方法重写

![image-20200926182649867](image/image-20200926182649867.png)

**Java的四大权限标识符**

- 从小到大

private——>default——>protected——>public

子类方法的访问权限不能比父类方法的访问权限低

举例

当dog要重写animal类的eat方法时

如果animal的eat方法是访问权限符是default（默认不写）时，

dog重写的这个eat方法的访问权限符不能时private

![image-20200926183710631](image/image-20200926183710631.png)

如图显示会报错



## 四大访问权限修饰符

![image-20200926183819819](image/image-20200926183819819.png)



## 方法重载和方法重写的区别

![image-20200926183939935](image/image-20200926183939935.png)



## Java中继承的特点

- Java只支持类的单继承，但是支持多层继承
- java支持接口的多继承
- 私有成员发不能继承（只能继承父类的非私有成员）
- 构造方法不能继承
- ![image-20200926184421254](image/image-20200926184421254.png)



# Java编程思想（面向对象多态）

![image-20200926191445979](image/image-20200926191445979.png)





## 什么是多态

**同一对象在不同情况下表现出来的状态或行为**

**比如**

- 水在不同温度表现出来的状态
- 人在不同情况担任的角色

## 实现多态的步骤

![image-20200926201113972](image/image-20200926201113972.png)

## 父类引用指向子类对象的内存图

![image-20200926202942058](image/image-20200926202942058.png)

编译看左（左边类型有没有这个成员），运行看右（运行时具体用的时右边类中的成员）

![image-20200926203559775](image/image-20200926203559775.png)

## 多态使用场景及其内存图

**dog和mouse都继承animal类并且重写了animal的eat方法**

当我们要输出dog和mouse的eat方法的时候，用传统的代码风格如下图↓  （可以看到，需要使用两个showanimal方法，这样显得很繁琐）

![image-20200927125438175](image/image-20200927125438175.png)

我们通过修改showanimal的如下图👇

![image-20200927125758847](image/image-20200927125758847.png)

**可以理解为，通过向上转型，dog和mouse的父类型接受他们。**









![image-20200927125205769](image/image-20200927125205769.png)



## 向上转型和向下转型

**向上转型：**顾名思义就是父类的引用变量去引用子类的实例

- **当向上转型之后，父类引用变量可以访问子类中属于父类的属性和方法，但是不能访问子类独有的属性和方法**

如下👇

![image-20200927132937652](image/image-20200927132937652.png)

可以看到play方法是dog类专属的，所以animal不能调用子类专属的方法



**向下转型**

- 并不是所有的对象都可以向下转型的，只有这个对象原本就是通过子类向上转型得到的，才能向下转型

  如👇

  ![image-20200927133451128](image/image-20200927133451128.png)



比如我们创建一个猫的实体对象，继承animal类

![image-20200927133758838](image/image-20200927133758838.png)

可以看到，虽然在编译阶段代码并没有报错，但是在运行的时候就会报错了

因为an是dog向上转型得到的，只能向下转型编程dog对象，而不能向下转型变成cat对象





**转型的好处**

![image-20200927134106187](image/image-20200927134106187.png)

## 多态中成员变量的使用（继承中的变量是不能重写的）

**创建一个animal类和一个dog类**

dog类继承animal类

如下👇

![image-20200927145132523](image/image-20200927145132523.png)

然后dog向上转型，看输出的name是哪个类的



![image-20200927145120355](image/image-20200927145120355.png)

![image-20200927145110578](image/image-20200927145110578.png)

**可以看到，输出的是animal中的name  吴亦凡**

所以在多态中，对于继承的变量的使用的规律是

![image-20200927145405732](image/image-20200927145405732.png)

**注意！！！**

> 在继承中，当我们私有化了成员属性后，我们就不能像上面一样直接调用成员属性了，只能通过get set方法来获取这些私有化的成员属性，所以，当我们在多态中将 dog向上转型到animal，然后调用get方法，获取的是dog属性的值，因为getset方法遵循方法的重写

举例如下👇

![image-20200927150415880](image/image-20200927150415880.png)

可以看到，dog向上转型到animal后，通过调用getname，获得的是dog这个name的值



**总结**

又内存图解可以看出

![image-20200927151145999](image/image-20200927151145999.png)

**方法区中是没有成员变量的，所以不能重写，与之对比的是方法重写时的内存图解**

如下👇

![image-20200927125205769](image/image-20200927125205769.png)

可以看出，方法是存放在方法区的，所以方法可以进行重写，所以在多态的向上转型时，就能调用到子类重写父类的方法。

## 多态的好处和弊端



![image-20200927153050566](image/image-20200927153050566.png)

![image-20200927153119973](image/image-20200927153119973.png)





## 抽象类的概述

举例

父子类一般如下👇

![image-20200927153730544](image/image-20200927153730544.png)

上面图中的代码有瑕疵的，因为父类的eat 的内容时吃饭，其实根本上就是一句废话，因为动物是一定要吃东西的

所以我们就进行一些优化，把方法体去掉，就变成了一个抽象方法了，然后这个抽象方法的类就是抽象类

![image-20200927154027838](image/image-20200927154027838.png)

![image-20200927154138456](image/image-20200927154138456.png)

实例如下👇

![image-20200927155955736](image/image-20200927155955736.png)



## 抽象类的特点

![image-20200927160221075](image/image-20200927160221075.png)

抽象类的成员特点

**Java中的成员分为成员属性、成员方法和构造方法**

 ![image-20200927160508466](image/image-20200927160508466.png)

## 案例——抽象类员工实现

通过子类构造方法实现

**在实际开发中，子类一般都有两个构造方法**

1. 子类空参构造访问父类空参构造
2. 子类全参构造访问父类全参构造

如下举例👇

![image-20200927170157316](image/image-20200927170157316.png)



## final关键字

![image-20200927183541594](image/image-20200927183541594.png)

1. final修饰的类是不能被继承的，所以不会有子类（但是被final修饰的类可以继承其他类）

比如：String、system这些类都是不能有子类的

如下，继承被final修饰的类会报错

![image-20200927184409604](image/image-20200927184409604.png)

2. final修饰的方法是不能被重写的

比如父类定义的一些方法只能被引用而不想要被子类修改，就需要final关键字来修饰

> 所以，final这个关键字和abstract是不能共存的
>
> 因为abstract修饰的方法是要求子类必须要重写这个方法的
>
> 而final修饰的方法是不能被重写的

3. 修饰变量，只能被赋值一次

![image-20200927184249473](image/image-20200927184249473.png)

如图，name变量被赋值一次后，第二次赋值就会报错 



**总结：final修饰的任何东西，是地址值不能被改变，而属性值是可以发生变化的**

![image-20200927185046769](image/image-20200927185046769.png)

如图是用final定义了一个变量，但是我们仍然可以更改这个变量对象里面的属性。



## static关键字

 ![image-20200927185414685](image/image-20200927185414685.png)

### 静态成员变量的使用

**举例**

当没有用static修饰变量的时候，department这个属性只能一个实例单独修改

![image-20200927194636756](image/image-20200927194636756.png)

当我们用static修饰department，那么这个类的所有实例 对象都会共享这个被static修饰的变量



![image-20200927194753896](image/image-20200927194753896.png)

可以看到，developer01实例修改了department这个属性后，developer02输出的department属性的值是一样的，说明department被共享了

修改department的另一种写法

```java
Developer.department = "开发部"；
```

## public final static的用法

- static是为了让其成为类的成员，而不是对象的成员，这样用起来就方便了就可以通过类名.变量名的方式调用

> ```java
> Developer.department = "开发部"；
> ```

- public是为了方便访问,降低访问权限
- final则是表明这是个常量，不能修改





### 静态成员方法的使用

![image-20200927201638477](image/image-20200927201638477.png)

![image-20200927202045261](image/image-20200927202045261.png)

如图可以看到，被static修饰的方法不能访问没有被static的成员属性，否则就会报错



## 接口的概述

![image-20200927204525016](image/image-20200927204525016.png)

![image-20200927204602558](image/image-20200927204602558.png)



![image-20200927205005110](image/image-20200927205005110.png)

接口的方法前默认是 public static 

![image-20200927205204099](image/image-20200927205204099.png)

![image-20200927205426786](image/image-20200927205426786.png)



![image-20200927210037921](image/image-20200927210037921.png)

**抽象类实现接口**

> 假如接口定义了a、b两个方法，而抽象里类定义了c方法
>
> 当类继承实现类之后，就需要必须要重写a、b、c三个方法
>
> **使用抽象类实现接口是为了减少代码冗余，将专门的类放在抽象类中**



![image-20200927212054510](image/image-20200927212054510.png)



## 接口成员的特点

**成员变量的特点**

![image-20200927213051903](image/image-20200927213051903.png)

其中 public static final是系统默认的，不写系统也会默认补充

如果调用接口常量，可以通过**接口名.常量名**的方式调用

![image-20200927213458997](image/image-20200927213458997.png)



![image-20200927213216562](image/image-20200927213216562.png)

![image-20200927213650024](image/image-20200927213650024.png)

![image-20200927214003288](image/image-20200927214003288.png)

接口的成员方法私有化后，就需要添加方法体，编写逻辑代码

![image-20200927214141179](image/image-20200927214141179.png)

**接口是没有构造方法的**





# Java的常用工具__api_

![image-20200927233803904](image/image-20200927233803904.png)

## api的概念

**什么是api**

![](image/image-20200927234109905.png)

![image-20200927234953362](image/image-20200927234953362.png)

## Object类

![image-20200927235528865](image/image-20200927235528865.png)

**所有的类都直接或间接继承Object类**

![image-20200928000309612](image/image-20200928000309612.png)

注意：框框里面的extends Object是系统默认的，可以写也可以不写，不写系统会默认加上



- 返回哈希码值（哈希码值是根据地址值计算出来的结果）

![image-20200928000947281](image/image-20200928000947281.png)

每个实例对象的哈希值一般都不一样

- 字节码文件Class

![image-20200928001340730](image/image-20200928001340730.png)

字节码文件一样，说明一个类只能有一个字节码文件对象



- toString 返回该对象的字符串表现形式（默认打印的是地址值，但是不同对象的地址值肯定不同）

> 地址值的组成（全类名+@+改对象的哈希码的无符号十六进制形式）
>
> ![image-20200928120418216](image/image-20200928120418216.png)



- 比较两个对象是否相等 boolean  equals()

![image-20200928120755109](image/image-20200928120755109.png)

默认比较地址值是否相等的，一般来说是无意义的，所以子类都会重写这个equals（）方法

## JavaBean重写object类中的方法

需求

![image-20200928122550320](image/image-20200928122550320.png)



- 重写equals方法

![image-20200928160641979](image/image-20200928160641979.png)

如图，通过id判断这个类的对象是否相同的案例中，因为上面的equals方法的定义的形式参数是Object类型的，当我们调用这个equals方法的时候，传入一个Student对象，就会把这个Student向上转型为Object类型，但是，因为这个id是子类Student特有的属性，父类Object是不能调用的，所以这个id就会报错

**如何解决这个问题呢？**

我们需要在equals这个方法里面，对传入的对象进行向下转型

![image-20200928161214183](image/image-20200928161214183.png)

将object类型转化为子类的Student类型，这样就能调用到id这个属性了，而且不会报错。

对于idea自动重写的equals方法的解读

![image-20200928163124238](image/image-20200928163124238.png)



## Scanner类

![image-20200928174925486](image/image-20200928174925486.png)

![image-20200924115812396](image/image-20200924115812396.png)



**为什么System类中，定义的静态属性in为空的原因**

![image-20200928180522994](image/image-20200928180522994.png)

- nextInt代表接收一个整数
- nextDouble表示接收一个小数

如果输入的数据类型不匹配，就会报错

![image-20200928181157767](image/image-20200928181157767.png)

那么如何避免这种错误发生呢

**我们可以在输入前做一个判断**

![image-20200928181327069](image/image-20200928181327069.png)

判断录入的是否是整数

- next()
- nextLine()

nex()的接收标记是空格，如下👇

![image-20200928182211422](image/image-20200928182211422.png)

可以看到，我输入了带空格的内容，最终输出的结果只有空格前的abd字符串



nextLine()的结束标记是换行符

![image-20200928182334446](image/image-20200928182334446.png)



## String类

![image-20200930163819656](image/image-20200930163819656.png)



举例

- 将指定的字节数组传入String
- 将指定的字符数组传入String

![image-20200930164625456](image/image-20200930164625456.png)

**因为实际开发中String使用非常频繁，每次都new就很麻烦，所以就省去了new的动作**

- equals()判断字符串是否相同，区分大小写
- equalsIgnoreCase()判断字符串是否相同，不区分大小写
- startsWith()是否以给定字符串开头
- isEmpty()判断字符串是否为空

## String为什么是不可变的

![image-20201015122632281](image/image-20201015122632281.png)

## String的获取功能

![image-20200930165832978](image/image-20200930165832978.png)



## String类的转换功能

![image-20201001153129667](image/image-20201001153129667.png)

- byte[]——getbyte()把字符串转换为字符数组

![image-20201001153539888](image/image-20201001153539888.png)

- char[]——tocharArray把字符串转换为字符数组

![image-20201001153921395](image/image-20201001153921395.png)



## Stringbuilder和Stringbuffer类

![image-20201001160910222](image/image-20201001160910222.png)





**将三个字符串拼接成一个字符串**

![image-20201001164726067](image/image-20201001164726067.png)

## String Stringbuilder Stringbuffer之间的区别

![image-20201001164942493](image/image-20201001164942493.png)

![image-20201001165006202](image/image-20201001165006202.png)

![image-20201001165109332](image/image-20201001165109332.png)

![blog.csdn.net_changgebuyu_article_details_86523998](image/blog.csdn.net_changgebuyu_article_details_86523998.png)



## Date和Calendar类

![image-20201001172957518](image/image-20201001172957518.png)

获取系统时间和毫秒数的使用

![image-20201001184044704](image/image-20201001184044704.png)



**calendar类**：抽象类   

![image-20201001213722979](image/image-20201001213722979.png)

## 基本类型的包装类

**拆箱和装箱的转换，归根到底，就是将字符串类型的数据转换成对应的数据类型**

![image-20201001221837655](image/image-20201001221837655.png)

基本类型和引用类型的区别

![image-20201001225056681](image/image-20201001225056681.png)

**装箱和拆箱**

![image-20201002100308532](image/image-20201002100308532.png)

**jdk5新特性，自动拆装箱**

![image-20201002100336903](image/image-20201002100336903.png)

**需求：将字符串类型转换成int类型**

![image-20201002101851811](image/image-20201002101851811.png)



**注意：除了character类之外，其他的包装类都又parse方法**

为什么呢

因为如果字符串想转换成char类型的数据，可以通过String类中的toCharArray（），charAt（）这两个方法



# Java常用工具__集合



![image-20201002140333463](image/image-20201002140333463.png)

![image-20201002142409778](image/image-20201002142409778.png)



## list集合的特点和应用

![image-20201002144755416](image/image-20201002144755416.png)

![image-20201002144915643](image/image-20201002144915643.png)

![image-20201002145305210](image/image-20201002145305210.png)



## 增强for循环和迭代器

![image-20201002150142380](image/image-20201002150142380.png)



红框圈的是向上转型后，对obj进行向下转型

快捷方式

![image-20201002150401022](image/image-20201002150401022.png)

![image-20201002150459554](image/image-20201002150459554.png)

## 迭代器的演示

![image-20201002162906105](image/image-20201002162906105.png)

![image-20201002163010066](image/image-20201002163010066.png)

![image-20201002163318398](image/image-20201002163318398.png)

![image-20201002163510233](image/image-20201002163510233.png)

画红框的这种添加方法是不可取的，会报错

相当于让一个人一边睡觉一边吃饭

在list中就是list正在变量中，不可以添加元素的，而且这是普通的迭代器

如果想完成这样的一个操作，需要通过 **列表迭代器** 来完成

![image-20201002163937222](image/image-20201002163937222.png)

## 泛型简介

 **类似于方法参数，形参定义的什么类型的参数，你就只能传什么类型的参数进去**

![image-20201002170436404](image/image-20201002170436404.png)

![image-20201002170552399](image/image-20201002170552399.png)

如图，因为没有使用泛型，当将int类型数据强制转换，就会报错

![image-20201002171141114](image/image-20201002171141114.png)

如图，添加String的泛型之后，只能添加String类型的元素

## 泛型类和泛型接口的演示

**泛型接口的定义**

<img src="image/image-20201024161224401.png" alt="image-20201024161224401" style="zoom: 67%;" />

**定义实现类实现上面的泛型接口**

<img src="image/image-20201024161448290.png" alt="image-20201024161448290" style="zoom:67%;" />

**如果实现接口的时候不规定泛型，那么返回类型为T的方法就可以自定义任何的返回类型**

<img src="image/image-20201024161738708.png" alt="image-20201024161738708" style="zoom:67%;" />

**定义一个泛型类**

<img src="image/image-20201024162014863.png" alt="image-20201024162014863" style="zoom:67%;" />

**继承这个类，泛型设置为String**

<img src="image/image-20201024162047072.png" alt="image-20201024162047072" style="zoom:67%;" />

> 和泛型接口一样，继承这个泛型类，重写这个类的泛型方法 ，就必须返回String类型，如果返回其他类型就会报错，如下:arrow_down_small:
>
> <img src="image/image-20201024162203083.png" alt="image-20201024162203083" style="zoom:67%;" />



**总结**

![image-20201002171328277](image/image-20201002171328277.png)

![image-20201002171258934](image/image-20201002171258934.png)



## Conllections工具类

![image-20201003112605637](image/image-20201003112605637.png)

**演示**

![image-20201003140919754](image/image-20201003140919754.png)



## set集合的特点

![image-20201003141237827](image/image-20201003141237827.png)

![image-20201003141335818](image/image-20201003141335818.png)

![image-20201003145557182](image/image-20201003145557182.png)

如图，虽然set集合是无序的，不可重复的，但是为什么会输出一样的值呢

> 因为set集合保证元素的唯一性依赖：equals()和hashcode()两个方法
>
> 如果没有在Rabbit类中重写这两个方法，默认调用的是Object类中的这两个方法。
>
> 而Object中的equals()方法默认比较的是地址值是否相同



## Map集合的特点和应用

![image-20201003151605199](image/image-20201003151605199.png)

**案例**

![image-20201003153940821](image/image-20201003153940821.png)

**演示**

![image-20201003154602775](image/image-20201003154602775.png)

![image-20201003155042695](image/image-20201003155042695.png)

![image-20201003155118575](image/image-20201003155118575.png)



**根据键获取值**

![image-20201003155630868](image/image-20201003155630868.png)



**遍历步骤**

![image-20201003155721435](image/image-20201003155721435.png)

![image-20201003160121412](image/image-20201003160121412.png)

![image-20201003160035899](image/image-20201003160035899.png)

**第二种方案（通过增强for）**

 

## 案例：模拟斗地主发牌

![image-20201003173302673](image/image-20201003173302673.png)

**买牌**

![image-20201003173354673](image/image-20201003173354673.png)



## 数组排序（compareTo,comparable,comparator）

**compareTo的使用方式**

![image-20221009210822426](image/image-20221009210822426.png)



**comparable和comparator的区别（多个案例）**

- 第一个



![juejin.cn_post_7027485262032666632(1)](image/juejin.cn_post_7027485262032666632(1).png)



- 第二个



![juejin.cn_post_7040821677667647524](image/juejin.cn_post_7040821677667647524.png)







# Java常用工具__IO流_

![image-20201004105122603](image/image-20201004105122603.png)

## 异常的概述

![image-20201004105811240](image/image-20201004105811240.png)

## try_catch

![](image/image-20201004105940753.png)

![image-20201004110006345](image/image-20201004110006345.png)



**JVM默认处理异常的方式，在控制台打印异常信息，并终止程序**

![image-20201004110311204](image/image-20201004110311204.png)

![image-20201004110339701](image/image-20201004110339701.png)

**案例演示**

![image-20201004112754711](image/image-20201004112754711.png)

**当输出除数为0**，捕获到异常后，程序依然在执行

![image-20201004112908771](image/image-20201004112908771.png)



**但是就算我把代码段不放在finally里面，放在catch外面，也能执行，那么这个finally有什么意义呢**

![image-20201004141023756](image/image-20201004141023756.png)

如上图，当我在catch内加入了return之后，程序就会终止了，但是finally中的代码依然还会执行

## throws抛出异常

![image-20201004142821249](image/image-20201004142821249.png)

如图，当show方法抛出一样后，main方法调用，然后main方法会把这个异常抛给jvm处理，然后jvm会把这个错误信息打印在控制台上，并且终止程序

所以，最终这个异常还是需要通过try catch来解决的

![image-20201004143311649](image/image-20201004143311649.png)



## IO流的概述

![image-20201004145835360](image/image-20201004145835360.png)



输入流：将数据读取到内存中

输出流：将数据从内存读取到指定的文件中

![image-20201004150346906](image/image-20201004150346906.png)

比如：当我们需要将a.txt文件中的内容复制到b.txt中

那么第一步是通过输入流将a.txt中的内容读取到文件中

第二步是通过输出流将数据从内存发读取到指定的文件中



![image-20201004151759422](image/image-20201004151759422.png)

![image-20201004151848800](image/image-20201004151848800.png)

![image-20201004151949085](image/image-20201004151949085.png)

![image-20201004163802047](image/image-20201004163802047.png)

**高效的意思是效率很高**

## 相对路径

![www.jianshu.com_p_68b044eba7f5](image/www.jianshu.com_p_68b044eba7f5.png)

## File类的创建及判断功能

![image-20201004165946915](image/image-20201004165946915.png)

**在 Java中路径的两种写法**

（因为\是Java中的转义字符，所以需要写两条）

![image-20201005134805742](image/image-20201005134805742.png)

**三种封装file对象的方式**

![image-20201005132436573](image/image-20201005132436573.png)



**需求：创建一个txt文件**

![image-20201005142916687](image/image-20201005142916687.png)

![image-20201005153016678](image/image-20201005153016678.png)



如果不存在则创建返回true

否则不创建返回false



![image-20201005153451228](image/image-20201005153451228.png)

![image-20201005153529437](image/image-20201005153529437.png)



## File类的获取功能

![image-20201005153648345](image/image-20201005153648345.png)

![image-20201005153749343](image/image-20201005153749343.png)

**获取绝对路径**

**获取相对路径**

**获取文件名**

![image-20201005154638797](image/image-20201005154638797.png)

**获取指定文件夹下所有的文件（夹）**

![image-20201005154740911](image/image-20201005154740911.png)

![image-20201005154852289](image/image-20201005154852289.png)



## 字符流读写文件__按单个字符读取

![image-20201005160138258](image/image-20201005160138258.png)

   ![image-20201005161212951](image/image-20201005161212951.png)

如图，每读取一次，就会返回一个字符代表的整数

所以，我们可以通过while循环来读取这个read()方法的数据据

![image-20201005162213529](image/image-20201005162213529.png)

第二种简便写法

![image-20201005162350547](image/image-20201005162350547.png)



##  字符流读写文件__按字符数组进行读取

![image-20201005165830575](image/image-20201005165830575.png)

![image-20201006102525544](image/image-20201006102525544.png)

**当我们把数组长度改为3，结果如下**

![image-20201006102820484](image/image-20201006102820484.png)

![l](image/image-20201006110314537.png)

**遍历字符数组**

![image-20201006110737184](image/image-20201006110737184.png)



## 字符流写数据

**按照单个字符写入**

![image-20201007093539813](image/image-20201007093539813.png)

**按字符数组写入**

![image-20201007093610042](image/image-20201007093610042.png)

**按字符串进行写入**

![image-20201007093637309](image/image-20201007093637309.png)



![image-20201007101015331](image/image-20201007101015331.png)



## 字符流拷贝文件

![image-20201007113447643](image/image-20201007113447643.png)



 **将a.txt文件中的内容，拷贝到b.txt文件中**

![image-20201007113331232](image/image-20201007113331232.png)

第二种写法

![image-20201007113532016](image/image-20201007113532016.png)



## 字符缓冲流普通用法

![image-20201007114206899](image/image-20201007114206899.png)

![image-20201007114128303](image/image-20201007114128303.png)

![1589787497291](image/1589787497291.png)

![image-20201007115155237](image/image-20201007115155237.png)

**缓冲流拷贝案例**

![image-20201007120624080](image/image-20201007120624080.png)

**但是，和上面显示的案例没什么区别，为什么要用到buffer呢**

![image-20201007120737714](image/image-20201007120737714.png)

点进去buffer的源码，可以看到里面内置了一个数组缓冲区，定义的大小为8192

底层是按照字符数组来读写的

>  java.io.BufferedReader和java.io.BufferedWriter类各拥有8192字符的缓冲区。当BufferedReader在读取文本文件时，会先尽量从文件中读入字符数据并置入缓冲区，而之后若使用read()方法，会先从缓冲区中进行读取。如果缓冲区数据不足，才会再从文件中读取，使用BufferedWriter时，写入的数据并不会先输出到目的地，而是先存储至缓冲区中。如果缓冲区中的数据满了，才会一次对目的地进行写出。

## 字符缓冲流一次读写一行

![image-20201007122911288](image/image-20201007122911288.png)

如图，当我通过一行一行读取数据后，然后通过write来写入，结果写入的数据不是一行一行写入的

![image-20201007123211411](image/image-20201007123211411.png)

可以通过write下面给出newline方法来换行

![image-20201007151828532](image/image-20201007151828532.png)

第二种换行的写法

![image-20201007151920224](image/image-20201007151920224.png)

因为Java是可以跨平台但是语言，所以newLine会根据不同的操作系统来给出对应的换行符



**注意：字符流是不可以拷贝图片的**



## 普通字节流一次读写一个字节

![image-20201007152254949](image/image-20201007152254949.png)

![image-20201007153517431](image/image-20201007153517431.png)



## 普通字节流一次读写一个字节数组

![image-20201007160602419](image/image-20201007160602419.png)

**一次性拷贝文件夹所有的图片** 

![image-20201007160502881](image/image-20201007160502881.png)



## 高效字节流的用法

![image-20201007164510988](image/image-20201007164510988.png)

# Java高级__反射



![image-20201007181625027](image/image-20201007181625027.png)

![image-20201007181647701](image/image-20201007181647701.png)

## 反射的基本概念

![image-20201007182310235](image/image-20201007182310235.png)

## 获取字节码文件对象的三种方法

![image-20201007182554479](image/image-20201007182554479.png)

![image-20201007182948991](image/image-20201007182948991.png)

 ![image-20201007183205749](image/image-20201007183205749.png)



**一个源文件对应一个字节码文件对象**



![image-20201007183306053](image/image-20201007183306053.png)



![image-20201007184208206](image/image-20201007184208206.png)

**比较三个clazz是否相同**

![image-20201007184926388](image/image-20201007184926388.png)



可以得出结论

**一个源文件对应一个字节码文件对象**

## 通过反射的方式获取构造方法并使用

![image-20201007185257091](image/image-20201007185257091.png)

![image-20201009094033458](image/image-20201009094033458.png)

![image-20201009094009007](image/image-20201009094009007.png)

![image-20201009094244979](image/image-20201009094244979.png)

## 通过反射的方式获取成员方法并使用

![image-20201009094502954](image/image-20201009094502954.png)

 ![image-20201009094545100](image/image-20201009094545100.png)

 **演示** 

![image-20201009101434362](image/image-20201009101434362.png)

**调用公共的带参方法**

 ![image-20201009101618443](image/image-20201009101618443.png)

**调用私有的带参方法**

![image-20201009102803518](image/image-20201009102803518.png)



## 获取setter方法给对象的属性设置值

![image-20201009103117618](image/image-20201009103117618.png)



## 通过放射的方式获取成员变量并使用

![image-20201009103538835](image/image-20201009103538835.png)

**演示**

![image-20201009104711700](image/image-20201009104711700.png)



# Java设计模式

> 什么是设计模式：设计模式就是在大量的实践中总结和理论化之后优选的代码结构、变成风格、以及解决问题的思考方式

## 单例设计模式（Singleton）

- 饿汉式单例模式

**演示**

![image-20201010135454855](image/image-20201010135454855.png)

- 懒汉式单例模式

**演示**

![image-20201010140302897](image/image-20201010140302897.png)



什么时候用，什么时候创建实例就是懒汉式



# 类中代码块

- 代码块用来初始化类、对象

- 代码块如果有修饰的话，只能是用static修斯

  

## **普通代码块**

> 在方法或语句中出现的{}就成为普通代码块，普通代码块一般的语句执行顺序由他们在代码中出现的顺序决定——先出现先执行

![image-20201010145601841](image/image-20201010145601841.png)

如图：通一个方法内的分别定义的代码块，不能定义变量名一样的变量

![image-20201010145727425](image/image-20201010145727425.png)







## 构造代码块

> 直接在类中定义，而且没有加static关键字的代码块，构造代码块在创建对象时被调用，每次创建对象都会被调用，**并且构造代码块的执行次序优先于类构造函数**

![image-20201010150533799](image/image-20201010150533799.png)

如图可以看到，构造代码块总线优先于构造方法执行的

## 静态代码块

![image-20201010151057557](image/image-20201010151057557.png)

静态代码块一般用来加载文件配置的







## 同步代码块

[按住control点击，页内跳转到同步代码块的笔记](#线程同步)

![image-20201014130536125](image/image-20201014130536125.png)







# 内部类

**概念：在一个类中定义一个类**

```java
public class 类名{
    public class 类名{}
}

```

内部类的格式定义如上



**内部类的访问特点**

- 内部类可以直接访问外部类的成员，包括私有
- 外部类要访问内部类的成员，必须创建对象

![image-20201012114437527](image/image-20201012114437527.png)



## 成员内部类

**在类中的成员位置**

> 外界如何创建**公共的**成员内部类

```java
外部类.内部类 对象名 = 外部类.内部类
Outer.Inner oi = new Outer().new Inner()
```

**演示 **

![image-20201012115721356](image/image-20201012115721356.png)

> 注意：以上格式只能创建公共的内部类



> 调用私有的成员内部类

![image-20201012120646796](image/image-20201012120646796.png)





## 局部内部类

**在类中的局部位置**

> 局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用该类可以直接访问内部类的成员,也可以访问方法内的局部变量

![image-20201012121106889](image/image-20201012121106889.png)



## 匿名内部类

**一种局部内部类的特殊形式**

![image-20201012121858541](image/image-20201012121858541.png)

**演示**

![image-20201012122534715](image/image-20201012122534715.png)

**第二种写法**

![image-20201012122819800](image/image-20201012122819800.png)





## 匿名内部类的应用

**当使用多态没有用到匿名内部类**

![image-20201012130107303](image/image-20201012130107303.png)



使用匿名内部类之后

![image-20201012130547341](image/image-20201012130547341.png)

# 多线程

## 进程

**正在运行的程序**

- 是系统进行资源分配和调用的独立单位
- 每个进程都有自己的内存空间和系统资源

![image-20201012131211368](image/image-20201012131211368.png)

## 线程

> 线程：是进程中的单个顺序控制流，是一条执行路径

- 单线程：一个进程如果只有一条执行路径，则成为单线程程序
- 多线程：一个进程如果有多条执行路径，则成为多线程程序

单线程程序演示

![image-20201012131853701](image/image-20201012131853701.png)

如图，当我们打开一个记事本，我们编辑一点进去，然后打开页面设置，但是我不想关闭页面设置而继续编辑文本，这时候发现我们的光标无法选择文本继续执行，只有完成页面设置中的编辑才可以继续编辑文本。

 **多线程程序演示**

![image-20201012132336591](image/image-20201012132336591.png)

如图扫雷程序，当我们点击第一个空格之后，右上角的时间就会开始走动，直到我们点击到炸弹才会停止

所以扫雷程序至少有两个顺序控制流

一个是记录时间的

一个是记录玩家操作的



## 继承Thread类实现多线程

**多线程的实现方式**

1. 方式一

- 定义一个类MyThread继承Thread类
- 在MyThread类中重写run（）方法
- 创建MyThread类的对象
- 启动线程

![image-20201013131202840](image/image-20201013131202840.png)

如图，调用多线程之后，程序就不会一步一步执行，所以输出的for循环的数字也不会输出1到30再输出下一个1到30，而是交错输出

 

**两个小问题**

1. 为什么要重写run方法呢

> 因为run（）是用来封装被线程执行的代码的

2. run（）方法和start（）方法的区别

> run()封装线程执行的代码，直接调用，相当于普通方法的调用
>
> start（）启动线程，然后由jvm调用此线程的run方法



## 设置或获取线程名称

**获取线程的名称getname()**

![image-20201013134108720](image/image-20201013134108720.png)

**设置线程的名称**

![image-20201013134224691](image/image-20201013134224691.png)



**通过带参的构造方法来设置线程名称**

![image-20201013134606651](image/image-20201013134606651.png)



**获取main方法当前线程的名字**

![image-20201013214320379](image/image-20201013214320379.png)



## 线程优先级

**线程调度**

![image-20201014083726027](image/image-20201014083726027.png)

![image-20201014084614837](image/image-20201014084614837.png)

如图，默认都为5



![image-20201014084717540](image/image-20201014084717540.png)

线程优先级的最大和最小



![image-20201014090459576](image/image-20201014090459576.png)

设置线程优先级

>  线程优先级高，仅代表线程获取cpu时间片的几率高，不代表每次都跑在最前面



## 线程控制

![image-20201014090649468](image/image-20201014090649468.png)



 **sleep方法的演示**

![image-20201014091335925](image/image-20201014091335925.png)

如图，当线程循环输出一次后，就会停留一秒，因为这三个线程的执行时间都少于一秒，总共的执行时间也少于一秒，所以，在一秒时间内三个线程互相争夺cpu的时间片



**join的演示**

![image-20201014091853605](image/image-20201014091853605.png)



**setDaemon方法的演示**

![image-20201014094724337](image/image-20201014094724337.png)



如图，当secoundThread线程 执行结束和后，线程1和2也都快速停止执行



## 线程的生命周期

![image-20201014095207243](image/image-20201014095207243.png)



## 实现Runnable接口

**实现步骤**

![image-20201014095545276](image/image-20201014095545276.png)

**为什么实现Runnable接口而不直接继承Thread类呢**

> 因为当我们的类实现了Runnale接口后，我们就可以继承其他类，而不会被Thread类占用一个继承位置



**演示**

![image-20201014101922080](image/image-20201014101922080.png)

**runnable接口的好处**

![image-20201014102131503](image/image-20201014102131503.png)



## 案例（买票）

![image-20201014102830685](image/image-20201014102830685.png)

![image-20201014110156537](image/image-20201014110156537.png)



**稍微简化一下程序**

![image-20201014112820612](image/image-20201014112820612.png)

如上，卖出了一样的票数，这是因为线程不同步造成的

>  比如线程1在抢到了cpu的时间片执行了--tickets_num之后，
>
> 被线程2强到了cpu的时间片也进行了 --tickets_num操作，
>
> 然后当线程1在再次抢到cpu的时间片后，执行下面的输出语句，就变成了卖出第二张票，因为ticket_num已经被减了两次了
>
> 所以当线程2再次抢到cpu的时间片并进行输出语句之后，就会和线程1一样输出一样的tickets_num的数量



**早上以上条件的原因如下**（判断数据是否会有安全问题的标准）

> - 是否是多线程环境
> - 是否共享数据
> - 是否有多条语句操作共享数据

而上述展示的代码皆满足了这三个条件





## 线程同步



![image-20201014125609690](image/image-20201014125609690.png)

解决的办法是如下

![image-20201014125503746](image/image-20201014125503746.png)

就是将上述被红色框框的代码锁起来，在任意时刻只能有一个线程进来 



## 同步代码块

 

![image-20201014132827744](image/image-20201014132827744.png)

**然后我们接上面的代码来演示一下**

![image-20201014132104512](image/image-20201014132104512.png)

然后，一样还是会出现相同的数据，为什么呢

> 因为虽然可以用任意对象作为一把锁，但是不能没次进入同步代码块的时候都new一把新的锁出来，这样上面就相当于有三把钥匙了，这样不能同步的。所以我们因为提前创建好一把钥匙，然后让这三个窗口共享

![image-20201014132626567](image/image-20201014132626567.png)

这样就能解决问题了

## 同步方法解决数据安全问题

![image-20201014134620963](image/image-20201014134620963.png)



**同步方法的演示**

```java
package com.sellTickets;

public class SellTickets implements Runnable {
    private int sellTickets_num = 20;
    private int i = 0;


    @Override
    public void run() {
        while (true) {
            if (i % 2 == 0) {
                synchronized (this) {
                    if (sellTickets_num > 0) {
                        sellTickets_num--;
                        System.out.println(Thread.currentThread().getName() + "窗口卖出了" + (20 - sellTickets_num) + "张票————同步代码块");
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }


            } else {
                sellTickets();
            }
            i++;
        }
    }

    public synchronized void sellTickets() {
        if (sellTickets_num > 0) {
            sellTickets_num--;
            System.out.println(Thread.currentThread().getName() + "窗口卖出了" + (20 - sellTickets_num) + "张票+++++同步方法");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

![image-20201014144949560](image/image-20201014144949560.png)



![image-20201014145053673](image/image-20201014145053673.png)



**同步静态方法的演示**

![image-20201014150920292](image/image-20201014150920292.png)

## 线程安全的类

- Stringbuffer
- Vector
- HashTable

 ![image-20201014152311482](image/image-20201014152311482.png)

## Lock锁

![image-20201014155908031](image/image-20201014155908031.png)

**演示**

![image-20201014160407626](image/image-20201014160407626.png)

一般都会将lock.unlock()放在finally里面，这样即使前面的代码出错之后，依然能进行释放锁的操作



## 生产者和消费者模式

![image-20201014161118013](image/image-20201014161118013.png)

![image-20201014161138264](image/image-20201014161138264.png)

![image-20201014161920723](image/image-20201014161920723.png)



**实例演示**

生产者每3秒生成5瓶奶，消费者每3秒喝一瓶奶

当奶箱的奶大于10瓶的时候

生产者停止生产奶，知道消费者喝到只剩下2两瓶奶，生产者继续生产



main方法

![image-20201014171655695](image/image-20201014171655695.png)

奶箱类

```java
package com.producerAndConsumer;

public class MilkBox {
    private int milk_num;
    //停止生产奶的临界值
    private final int MAX_MILK_NUM = 10;
    //奶箱的正常状态
    private final int NOR_MILK_MUN = 2;


    public synchronized void  putMilk(int milk) {
        if (milk_num > MAX_MILK_NUM) {
            try {
                super.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

        this.milk_num += milk;
        System.out.println("当前奶的数量为" + milk_num);
    }

    public synchronized void getMilk() {
        if (milk_num == NOR_MILK_MUN) {
            super.notifyAll();
        }
        milk_num--;

    }


}
```

生产者类

```java
package com.producerAndConsumer;

public class Producer implements Runnable {
    private MilkBox milkBox;
    private int pro_milk = 1;

    public Producer() {
    }

    //获取奶箱
    public Producer(MilkBox mb) {
        this.milkBox = mb;
    }


    @Override
    public void run() {
        while (true) {
//生产者每3秒生成5瓶牛奶
            for (int i = 0; i < 5; i++) {
                milkBox.putMilk(pro_milk);
            }
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

    }
}
```

消费者类

```java
package com.producerAndConsumer;

public class Consumer implements Runnable {
    private MilkBox milkBox;
    private int drink_milk_num;

    public Consumer() {
    }

    public Consumer(MilkBox milkBox) {
        this.milkBox = milkBox;
    }

    @Override
    public void run() {
        while (true) {
            //消费者每3秒喝一瓶奶
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            milkBox.getMilk();
            drink_milk_num++;
            System.out.println("消费者一共喝了" + drink_milk_num + "瓶奶");
        }
    }
}
```



运行结果i

![image-20201014171852019](image/image-20201014171852019.png)





# 网络编程

## 网络编程的概述

**网络编程**

- 在网络通信协议下，实现网络互联的不同计算机上运行的程序间可以进行数据交换

![image-20201015110737714](image/image-20201015110737714.png)



## 网络编程的三要素

![image-20201015111227228](image/image-20201015111227228.png)

## IP地址

![image-20201015111447216](image/image-20201015111447216.png)

![image-20201015111744896](image/image-20201015111744896.png)

## InetAddress

![image-20201015112135734](image/image-20201015112135734.png)

**演示**

![image-20201015113152768](image/image-20201015113152768.png)

## 端口和协议



 ![image-20201015113404192](image/image-20201015113404192.png)

![image-20201015113539403](image/image-20201015113539403.png)

![image-20201015113746789](image/image-20201015113746789.png)

![image-20201015113707967](image/image-20201015113707967.png)

## UDP发送数据

> UDP发送端只负责发送数据，而不管接收端是否接收到
>
> 接收端只管接收数据，而不会向发送端进行反馈

![image-20201015113959551](image/image-20201015113959551.png)

****

**UDP发送数据**

![image-20201015114116119](image/image-20201015114116119.png)

![image-20201015120435259](image/image-20201015120435259.png)

**udp发送端代码演示**

```java
public static void main(String[] args) throws IOException {
    //创建udp协议的发送端
    DatagramSocket ds = new DatagramSocket();
    //准备数据
    byte[] b = "陈立繁的大白兔".getBytes();
    int byteLen = b.length;
    InetAddress inetAddress = InetAddress.getByName("LAPTOP-Q3H5DDTC");
    int port = 17787;
    //创建数据包
    DatagramPacket dp = new DatagramPacket(b, byteLen, inetAddress, port);
    ds.send(dp);
    ds.close();

}
```

## UDP接收数据

![image-20201015122943933](image/image-20201015122943933.png)

## UDP通信程序的练习

![image-20201015124559215](image/image-20201015124559215.png)

![image-20201015140543971](image/image-20201015140543971.png)



## TCP发送数据

![image-20201015141444968](image/image-20201015141444968.png)

![image-20201015141459189](image/image-20201015141459189.png)





## TCP接收数据

**tcp接收发送数据演示**

![image-20201015153942771](image/image-20201015153942771.png)



## TCP练习1（服务器给出反馈）

![image-20201015161143902](image/image-20201015161143902.png)

![image-20201015161125952](image/image-20201015161125952.png)

## TCP练习2（客户端数据来自于键盘）

![image-20201016144142515](image/image-20201016144142515.png)

![image-20201016144113193](image/image-20201016144113193.png)

## TCP练习3（服务器数据写入文本文件）

![image-20201016144151472](image/image-20201016144151472.png)

![image-20201016145744191](image/image-20201016145744191.png)

只需要更改服务端的部分代码

## TCP练习4（客户端数据来自于文本文件）

![image-20201016145845405](image/image-20201016145845405.png)

![image-20201016150542075](image/image-20201016150542075.png)

只需要修改客户端部分代码进行对文本文件的读取

## TCP练习5（上传文件，服务器给出反馈）

![image-20201016150628268](image/image-20201016150628268.png)

![image-20201016154647009](image/image-20201016154647009.png)

# Lambda表达式

![image-20201016160259666](image/image-20201016160259666.png)



**三种实现多线程的方式**

![image-20201016225218622](image/image-20201016225218622.png)

## Lambda表达式的标准格式

![image-20201016225450828](image/image-20201016225450828.png)

![image-20201016225507911](image/image-20201016225507911.png)

## Lambda（抽象方法无参无返回）

![image-20201016225642875](image/image-20201016225642875.png)

**演示**

 ![image-20201016231133806](image/image-20201016231133806.png)



## Lambda表达式（带参无返回值）

![image-20201016231959781](image/image-20201016231959781.png)

## Lambda(抽象方法带参带返回值)

![image-20201016232651755](image/image-20201016232651755.png)

## Lambda表达式的省略模式

![image-20201016234435183](image/image-20201016234435183.png)

## Lambda注意事项

![image-20201016234708712](image/image-20201016234708712.png)

## Lambda表达式和匿名内部类的区别

![image-20201016235112404](image/image-20201016235112404.png)



# 枚举

[点击查看枚举的教程](https://www.w3cschool.cn/java/java-enum-types.html)

## 枚举类型

![枚举类型](image/枚举类型-1603726724376.png)

## 枚举值

![枚举值](image/枚举值-1603726733549.png)

## 枚举类

![枚举类](image/枚举类-1603726785621.png)

## 枚举方法

![枚举方法](image/枚举方法-1603726793287.png)

## 枚举主体

![枚举主体](image/枚举主体-1603726797613.png)

## 枚举比较

![枚举比较](image/枚举比较-1603726804670.png)

# 模块化

![image-20201017085013054](image/image-20201017085013054.png)

